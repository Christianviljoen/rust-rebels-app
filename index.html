<script>
(() => {
  /***********************
   * SUPABASE (OPTIONAL) *
   ***********************/
  const SUPABASE_URL = "https://byeugnubtwdnlyzxcegf.supabase.co";
  const SUPABASE_ANON_KEY = "sb_publishable_zc6vOE2kCKmOLOLQUr1P5Q_nQHO1LzI";

  // If you truly want "anyone can see everything and write if password ok":
  // You STILL need auth for writes if RLS is enabled. If you disable RLS,
  // then anyone can write without login (not recommended).
  // This code: read + write only when logged in. Otherwise local-only.

  const sb = (window.supabase && SUPABASE_URL.includes("http") && SUPABASE_ANON_KEY.includes("ey"))
    ? window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY)
    : null;

  let currentUser = null;

  // Show text in footer so it never nags with popups
  function setSyncText(html){
    const el = document.getElementById("syncStatus");
    if(el) el.innerHTML = html;
  }

  function canWriteCloud(){
    return !!(sb && currentUser);
  }

  async function initAuthPassive(){
    if(!sb){
      setSyncText(`Sync: <b>off</b> • <span class="muted">Supabase not configured</span>`);
      return;
    }
    const { data } = await sb.auth.getSession();
    currentUser = data?.session?.user || null;

    if(currentUser){
      setSyncText(`Sync: <b>on</b> • logged in as <span class="muted">${currentUser.email || "user"}</span>`);
      await cloudPullAll(); // load from cloud into local state
      renderAll();
      startRealtime();
    } else {
      setSyncText(`Sync: <b>local</b> • <span class="muted">tap Sync/Login to enable</span>`);
    }
  }

  async function loginFlow(){
    if(!sb){
      alert("Supabase not configured. Add your URL + anon key.");
      return;
    }
    const email = prompt("Email:");
    if(!email) return;
    const password = prompt("Password:");
    if(!password) return;

    const { data, error } = await sb.auth.signInWithPassword({ email, password });
    if(error){ alert(error.message); return; }

    currentUser = data.user;
    setSyncText(`Sync: <b>on</b> • logged in as <span class="muted">${currentUser.email || "user"}</span>`);
    await cloudPullAll();
    renderAll();
    startRealtime();
  }

  async function logoutFlow(){
    if(!sb) return;
    await sb.auth.signOut();
    currentUser = null;
    setSyncText(`Sync: <b>local</b> • <span class="muted">logged out</span>`);
  }

  /***********************
   * 1) YOUR ORIGINAL APP *
   ***********************/
  const STORAGE_KEY = "rr_quotes_hours_v1";

  const uid = () => Math.random().toString(16).slice(2) + Date.now().toString(16);

  const money = (n) => {
    const x = Number(n || 0);
    return x.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  };

  const hoursFromTimes = (start, end, breakMin) => {
    if(!start || !end) return null;
    const [sh, sm] = start.split(":").map(Number);
    const [eh, em] = end.split(":").map(Number);
    let mins = (eh*60+em) - (sh*60+sm);
    if(mins < 0) mins += 24*60;
    mins -= Number(breakMin || 0);
    return Math.max(0, mins/60);
  };

  const state = loadState();

  function loadState(){
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw){
      try { return JSON.parse(raw); } catch {}
    }
    return {
      settings: { defaultRate: 75, biz: { name: "Rust Rebels", phone:"", email:"", address:"" } },
      jobs: []
    };
  }
  function saveState(){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    renderAll();
  }

  // Elements
  const jobList = document.getElementById("jobList");
  const jobCard = document.getElementById("jobCard");
  const settingsCard = document.getElementById("settingsCard");
  const kpis = document.getElementById("kpis");

  const search = document.getElementById("search");
  const filterStatus = document.getElementById("filterStatus");

  const defaultRate = document.getElementById("defaultRate");
  const bizName = document.getElementById("bizName");
  const bizPhone = document.getElementById("bizPhone");
  const bizEmail = document.getElementById("bizEmail");
  const bizAddress = document.getElementById("bizAddress");
  const rateFooter = document.getElementById("rateFooter");
  const newJobBtn = document.getElementById("newJobBtn");
  const closeJobBtn = document.getElementById("closeJobBtn");
  const deleteJobBtn = document.getElementById("deleteJobBtn");
  const saveJobBtn = document.getElementById("saveJobBtn");
  const backupBtn = document.getElementById("backupBtn");
  const wipeBtn = document.getElementById("wipeBtn");
  const importFile = document.getElementById("importFile");
  const exportCsvBtn = document.getElementById("exportCsvBtn");

  // Job fields
  const jobHeader = document.getElementById("jobHeader");
  const jobSub = document.getElementById("jobSub");
  const jobClient = document.getElementById("jobClient");
  const jobTitle = document.getElementById("jobTitle");
  const jobDesc = document.getElementById("jobDesc");
  const jobLocation = document.getElementById("jobLocation");
  const jobNotes = document.getElementById("jobNotes");
  const jobStatus = document.getElementById("jobStatus");
  const jobRate = document.getElementById("jobRate");

  // Time inputs
  const tDate = document.getElementById("tDate");
  const tRate = document.getElementById("tRate");
  const tStart = document.getElementById("tStart");
  const tEnd = document.getElementById("tEnd");
  const tDuration = document.getElementById("tDuration");
  const tBreak = document.getElementById("tBreak");
  const tDesc = document.getElementById("tDesc");
  const addTimeBtn = document.getElementById("addTimeBtn");
  const timeTableBody = document.querySelector("#timeTable tbody");
  const timeTotals = document.getElementById("timeTotals");

  // Materials inputs
  const mItem = document.getElementById("mItem");
  const mQty = document.getElementById("mQty");
  const mUnit = document.getElementById("mUnit");
  const mSell = document.getElementById("mSell");
  const mNote = document.getElementById("mNote");
  const addMatBtn = document.getElementById("addMatBtn");
  const matTableBody = document.querySelector("#matTable tbody");
  const matTotals = document.getElementById("matTotals");

  // PDF
  const pdfType = document.getElementById("pdfType");
  const pdfItemised = document.getElementById("pdfItemised");
  const pdfGroupDays = document.getElementById("pdfGroupDays");
  const genPdfBtn = document.getElementById("genPdfBtn");

  // Tabs
  const tabs = Array.from(document.querySelectorAll(".tab"));
  const tabPanels = {
    details: document.getElementById("tab-details"),
    time: document.getElementById("tab-time"),
    materials: document.getElementById("tab-materials"),
    pdf: document.getElementById("tab-pdf"),
  };

  let selectedJobId = null;

  function getJob(id){ return state.jobs.find(j => j.id === id); }

  function jobRateResolved(job){
    const r = job.rateOverride;
    return (r !== null && r !== undefined && r !== "") ? Number(r) : Number(state.settings.defaultRate || 0);
  }

  function calcLabor(job){
    const entries = job.timeEntries || [];
    let totalH = 0, total$ = 0;
    for(const e of entries){ totalH += Number(e.hours || 0); total$ += Number(e.cost || 0); }
    return { hours: totalH, cost: total$ };
  }

  function calcMaterials(job){
    const items = job.materials || [];
    let total = 0;
    for(const it of items){ total += Number(it.total || 0); }
    return { cost: total };
  }

  function badgeClass(status){
    if(status==="QUOTE") return "quote";
    if(status==="IN_PROGRESS") return "progress";
    if(status==="COMPLETED") return "done";
    if(status==="INVOICED") return "invoiced";
    return "";
  }
  function statusLabel(status){
    return status==="IN_PROGRESS" ? "In Progress" : status.charAt(0)+status.slice(1).toLowerCase().replace("_"," ");
  }

  function initSettings(){
    defaultRate.value = state.settings.defaultRate ?? 75;
    bizName.value = state.settings.biz?.name ?? "Rust Rebels";
    bizPhone.value = state.settings.biz?.phone ?? "";
    bizEmail.value = state.settings.biz?.email ?? "";
    bizAddress.value = state.settings.biz?.address ?? "";
    rateFooter.textContent = "$" + money(state.settings.defaultRate ?? 75);
  }

  // settings events
  defaultRate.addEventListener("input", async () => {
    state.settings.defaultRate = Number(defaultRate.value || 0);
    saveState();
    await cloudUpsertSettings(); // optional, safe
  });
  for(const [el, key] of [[bizName,"name"],[bizPhone,"phone"],[bizEmail,"email"],[bizAddress,"address"]]){
    el.addEventListener("input", async () => {
      state.settings.biz = state.settings.biz || {};
      state.settings.biz[key] = el.value;
      saveState();
      await cloudUpsertSettings(); // optional, safe
    });
  }

  newJobBtn.addEventListener("click", async () => {
    const now = new Date().toISOString();
    const job = {
      id: uid(),
      client: "",
      title: "New job",
      desc: "",
      location: "",
      notes: "",
      status: "QUOTE",
      rateOverride: "",
      createdAt: now,
      updatedAt: now,
      timeEntries: [],
      materials: []
    };
    state.jobs.unshift(job);
    selectedJobId = job.id;
    saveState();
    openJob(job.id);

    // cloud save only if logged in
    await cloudUpsertJob(job).catch(console.error);
  });

  closeJobBtn.addEventListener("click", () => { selectedJobId = null; renderAll(); });

  deleteJobBtn.addEventListener("click", async () => {
    const job = getJob(selectedJobId);
    if(!job) return;
    if(confirm("Delete this job? This cannot be undone.")){
      const id = selectedJobId;
      state.jobs = state.jobs.filter(j => j.id !== id);
      selectedJobId = null;
      saveState();
      await cloudDeleteJob(id).catch(console.error);
    }
  });

  saveJobBtn.addEventListener("click", async () => {
    const job = getJob(selectedJobId);
    if(!job) return;
    job.client = jobClient.value.trim();
    job.title = jobTitle.value.trim();
    job.desc = jobDesc.value.trim();
    job.location = jobLocation.value.trim();
    job.notes = jobNotes.value.trim();
    job.status = jobStatus.value;
    job.rateOverride = jobRate.value === "" ? "" : Number(jobRate.value);
    job.updatedAt = new Date().toISOString();
    saveState();
    await cloudUpsertJob(job).catch(console.error);
    alert("Saved.");
  });

  search.addEventListener("input", renderAll);
  filterStatus.addEventListener("change", renderAll);

  addTimeBtn.addEventListener("click", async () => {
    const job = getJob(selectedJobId);
    if(!job) return;

    const date = tDate.value || new Date().toISOString().slice(0,10);
    const rate = Number(tRate.value || jobRateResolved(job));
    const br = Number(tBreak.value || 0);

    let hrs = null;
    const fromTimes = hoursFromTimes(tStart.value, tEnd.value, br);
    if(fromTimes !== null) hrs = fromTimes;

    const dur = tDuration.value !== "" ? Number(tDuration.value) : null;
    if(dur !== null && !isNaN(dur) && dur > 0) hrs = (dur - (br/60));

    if(hrs === null || isNaN(hrs) || hrs <= 0){
      alert("Enter start/end time OR a duration (hours).");
      return;
    }

    const desc = tDesc.value.trim() || "Work";
    const cost = hrs * rate;

    const entry = {
      id: uid(),
      date,
      desc,
      hours: Number(hrs.toFixed(2)),
      rate,
      cost: Number(cost.toFixed(2)),
      start: tStart.value || "",
      end: tEnd.value || "",
      breakMin: br
    };

    job.timeEntries.push(entry);
    job.updatedAt = new Date().toISOString();

    tStart.value = ""; tEnd.value = ""; tDuration.value = ""; tDesc.value = ""; tBreak.value = "0";
    saveState();

    await cloudUpsertJob(job).catch(console.error);
    await cloudInsertTime(job.id, entry).catch(console.error);
  });

  addMatBtn.addEventListener("click", async () => {
    const job = getJob(selectedJobId);
    if(!job) return;

    const item = mItem.value.trim();
    if(!item){ alert("Enter an item name."); return; }

    const qty = Number(mQty.value || 1);
    const unit = Number(mUnit.value || 0);
    const sellOverride = (mSell.value === "" ? null : Number(mSell.value));
    const total = sellOverride !== null ? sellOverride : qty * unit;

    const mat = {
      id: uid(),
      item,
      qty: Number(qty.toFixed(2)),
      unit: Number(unit.toFixed(2)),
      sell: sellOverride,
      total: Number(total.toFixed(2)),
      note: mNote.value.trim()
    };

    job.materials.push(mat);
    job.updatedAt = new Date().toISOString();

    mItem.value=""; mQty.value="1"; mUnit.value="0"; mSell.value=""; mNote.value="";
    saveState();

    await cloudUpsertJob(job).catch(console.error);
    await cloudInsertMat(job.id, mat).catch(console.error);
  });

  // Tabs
  tabs.forEach(btn => btn.addEventListener("click", () => {
    tabs.forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
    const name = btn.dataset.tab;
    Object.entries(tabPanels).forEach(([k, el]) => el.classList.toggle("hidden", k !== name));
  }));

  // Backup import/export
  backupBtn.addEventListener("click", () => {
    const blob = new Blob([JSON.stringify(state, null, 2)], {type:"application/json"});
    downloadBlob(blob, `rust-rebels-backup-${new Date().toISOString().slice(0,10)}.json`);
  });

  importFile.addEventListener("change", async () => {
    const f = importFile.files?.[0];
    if(!f) return;
    try{
      const txt = await f.text();
      const obj = JSON.parse(txt);
      if(!obj || !obj.settings || !obj.jobs) throw new Error("Invalid backup");
      if(confirm("Import backup? This will replace current data.")){
        state.settings = obj.settings;
        state.jobs = obj.jobs;
        selectedJobId = null;
        saveState();
      }
    }catch(e){
      alert("Could not import: " + e.message);
    }finally{
      importFile.value = "";
    }
  });

  wipeBtn.addEventListener("click", () => {
    if(confirm("Clear ALL data (jobs, hours, materials, settings)?")){
      localStorage.removeItem(STORAGE_KEY);
      location.reload();
    }
  });

  exportCsvBtn.addEventListener("click", () => {
    const rows = [];
    rows.push(["JobID","Client","Title","Status","Rate","LaborHours","LaborCost","MaterialsCost","Total","UpdatedAt"].join(","));
    for(const j of state.jobs){
      const r = jobRateResolved(j);
      const labor = calcLabor(j);
      const mats = calcMaterials(j);
      const total = labor.cost + mats.cost;
      rows.push([j.id, csv(j.client), csv(j.title), j.status, r,
        labor.hours.toFixed(2), labor.cost.toFixed(2), mats.cost.toFixed(2), total.toFixed(2), j.updatedAt
      ].join(","));
    }
    const blob = new Blob([rows.join("\n")], {type:"text/csv"});
    downloadBlob(blob, `rust-rebels-jobs-${new Date().toISOString().slice(0,10)}.csv`);
  });

  function csv(s){
    const x = (s ?? "").toString().replaceAll('"','""');
    return `"${x}"`;
  }
  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1500);
  }

  // PDF generation (your existing code kept)
  genPdfBtn.addEventListener("click", () => {
    const job = getJob(selectedJobId);
    if(!job) return;

    const docType = pdfType.value;
    const itemised = pdfItemised.value === "YES";
    const groupDays = pdfGroupDays.value === "YES";

    const labor = calcLabor(job);
    const mats = calcMaterials(job);
    const total = labor.cost + mats.cost;
    const rateUsed = jobRateResolved(job);
    const biz = state.settings.biz || {};

    const timeEntries = (job.timeEntries || []).slice().sort((a,b)=> (a.date||"").localeCompare(b.date||""));
    const materials = (job.materials || []);

    const grouped = {};
    if(groupDays){
      for(const e of timeEntries){
        grouped[e.date] = grouped[e.date] || {hours:0, cost:0, lines:[]};
        grouped[e.date].hours += Number(e.hours||0);
        grouped[e.date].cost += Number(e.cost||0);
        grouped[e.date].lines.push(e);
      }
    }

    const win = window.open("", "_blank");
    if(!win){ alert("Pop-up blocked. Allow pop-ups to generate PDF."); return; }

    const title = docType==="QUOTE" ? "QUOTE" : "INVOICE / WORK SUMMARY";
    const clientLine = job.client ? `<div><b>Client:</b> ${escapeHtml(job.client)}</div>` : "";
    const locationLine = job.location ? `<div><b>Location:</b> ${escapeHtml(job.location)}</div>` : "";

    const bizBlock = `
      <div class="biz">
        <div class="bn">${escapeHtml(biz.name || "Rust Rebels")}</div>
        <div class="muted">${[biz.address, biz.phone, biz.email].filter(Boolean).map(escapeHtml).join(" • ")}</div>
      </div>
    `;

    const jobBlock = `
      <div class="box">
        <div class="h">${escapeHtml(job.title || "Job")}</div>
        ${clientLine}
        ${locationLine}
        <div><b>Status:</b> ${escapeHtml(statusLabel(job.status || "QUOTE"))}</div>
        <div><b>Hourly rate:</b> $${money(rateUsed)}/hr</div>
        ${job.desc ? `<div class="sp"></div><div class="muted">${escapeHtml(job.desc)}</div>` : ""}
      </div>
    `;

    const totalsBlock = `
      <div class="totals">
        <div class="row"><span>Labour</span><b>$${money(labor.cost)}</b></div>
        <div class="row"><span>Materials</span><b>$${money(mats.cost)}</b></div>
        <div class="row grand"><span>Total (no GST)</span><b>$${money(total)}</b></div>
      </div>
    `;

    const acceptance = docType==="QUOTE" ? `
      <div class="box">
        <div class="h">Acceptance</div>
        <div class="muted">Signature: ____________________________  Date: ____ / ____ / ______</div>
      </div>
    ` : "";

    const timeTable = () => {
      if(!itemised) return "";
      if(timeEntries.length === 0) return `<div class="muted">No labour entries.</div>`;
      if(groupDays){
        const rows = Object.keys(grouped).map(d => `
          <tr><td>${escapeHtml(d)}</td><td class="right">${money(grouped[d].hours)}</td><td class="right">$${money(grouped[d].cost)}</td></tr>
        `).join("");
        return `
          <div class="box">
            <div class="h">Labour (grouped by day)</div>
            <table>
              <thead><tr><th>Date</th><th class="right">Hours</th><th class="right">$</th></tr></thead>
              <tbody>${rows}</tbody>
            </table>
          </div>
        `;
      }
      const rows = timeEntries.map(e => `
        <tr><td>${escapeHtml(e.date||"")}</td><td>${escapeHtml(e.desc||"")}</td><td class="right">${money(e.hours||0)}</td><td class="right">$${money(e.cost||0)}</td></tr>
      `).join("");
      return `
        <div class="box">
          <div class="h">Labour (itemised)</div>
          <table>
            <thead><tr><th>Date</th><th>Description</th><th class="right">Hours</th><th class="right">$</th></tr></thead>
            <tbody>${rows}</tbody>
          </table>
        </div>
      `;
    };

    const matTable = () => {
      if(!itemised) return "";
      if(materials.length === 0) return `<div class="muted">No materials/expenses.</div>`;
      const rows = materials.map(m => `
        <tr>
          <td>${escapeHtml(m.item||"")}${m.note ? `<div class="muted">${escapeHtml(m.note)}</div>` : ""}</td>
          <td class="right">${money(m.qty||0)}</td>
          <td class="right">$${money(m.total||0)}</td>
        </tr>
      `).join("");
      return `
        <div class="box">
          <div class="h">Materials / Expenses</div>
          <table>
            <thead><tr><th>Item</th><th class="right">Qty</th><th class="right">$</th></tr></thead>
            <tbody>${rows}</tbody>
          </table>
        </div>
      `;
    };

    win.document.write(`
      <html><head><meta charset="utf-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>${escapeHtml(title)} - ${escapeHtml(job.title || "Job")}</title>
      <style>
        body{ font-family:-apple-system,system-ui,Segoe UI,Roboto,Arial; margin:28px; color:#111; }
        .top{ display:flex; justify-content:space-between; gap:16px; }
        .bn{ font-size:18px; font-weight:800; }
        .muted{ color:#555; font-size:12px; }
        .doc{ text-align:right; }
        .doc .t{ font-size:20px; font-weight:900; }
        .box{ margin-top:16px; padding:14px; border:1px solid #ddd; border-radius:12px; }
        .h{ font-weight:900; margin-bottom:8px; }
        table{ width:100%; border-collapse:collapse; }
        th,td{ font-size:12px; padding:8px 6px; border-bottom:1px solid #eee; vertical-align:top; }
        th{ color:#555; text-align:left; }
        .right{ text-align:right; }
        .totals{ margin-top:16px; padding:14px; border:1px solid #ddd; border-radius:12px; }
        .totals .row{ display:flex; justify-content:space-between; padding:6px 0; font-size:13px; }
        .totals .grand{ border-top:1px dashed #ccc; margin-top:6px; padding-top:10px; font-size:15px; }
        @media print{ body{ margin:0.5cm; } }
      </style></head><body>
        <div class="top">
          ${bizBlock}
          <div class="doc">
            <div class="t">${escapeHtml(title)}</div>
            <div class="muted">Date: ${new Date().toISOString().slice(0,10)}</div>
          </div>
        </div>
        ${jobBlock}
        ${timeTable()}
        ${matTable()}
        ${totalsBlock}
        ${acceptance}
        <div class="muted" style="margin-top:14px">No GST applied.</div>
        <script>setTimeout(() => window.print(), 250);<\/script>
      </body></html>
    `);
    win.document.close();
  });

  function escapeHtml(s){
    return (s ?? "").toString()
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function openJob(id){
    selectedJobId = id;
    renderAll();
    jobCard.scrollIntoView({behavior:"smooth", block:"start"});
  }

  function renderKPIs(){
    const visible = filteredJobs();
    let active = 0, quoted = 0, completed = 0;
    let total$ = 0;
    for(const j of visible){
      if(j.status==="IN_PROGRESS") active++;
      if(j.status==="QUOTE") quoted++;
      if(j.status==="COMPLETED" || j.status==="INVOICED") completed++;
      const labor = calcLabor(j);
      const mats = calcMaterials(j);
      total$ += (labor.cost + mats.cost);
    }
    kpis.innerHTML = `
      <span class="pill">Jobs: <b>${visible.length}</b></span>
      <span class="pill">Quotes: <b>${quoted}</b></span>
      <span class="pill">Active: <b>${active}</b></span>
      <span class="pill">Done: <b>${completed}</b></span>
      <span class="pill">Total value: <b>$${money(total$)}</b></span>
    `;
  }

  function filteredJobs(){
    const q = (search.value || "").trim().toLowerCase();
    const st = filterStatus.value || "";
    return state.jobs.filter(j => {
      const hay = `${j.client} ${j.title} ${j.desc} ${j.notes} ${j.location}`.toLowerCase();
      return (!q || hay.includes(q)) && (!st || j.status === st);
    });
  }

  function renderJobList(){
    const jobs = filteredJobs();
    jobList.innerHTML = "";
    if(jobs.length === 0){
      jobList.innerHTML = `<div class="muted" style="padding:10px 2px">No jobs yet. Tap “New Job”.</div>`;
      return;
    }
    for(const j of jobs){
      const labor = calcLabor(j);
      const mats = calcMaterials(j);
      const total = labor.cost + mats.cost;
      const el = document.createElement("div");
      el.className = "jobItem";
      el.innerHTML = `
        <div>
          <div class="jobTitle">${escape(j.title || "Job")}</div>
          <div class="jobMeta">${escape(j.client || "No client")} • $${money(total)} • ${money(labor.hours)}h</div>
        </div>
        <div class="badge ${badgeClass(j.status)}">${escape(statusLabel(j.status || "QUOTE"))}</div>
      `;
      el.addEventListener("click", () => openJob(j.id));
      jobList.appendChild(el);
    }
  }

  function escape(s){ return (s ?? "").toString().replaceAll("<","&lt;").replaceAll(">","&gt;"); }

  function renderSelectedJob(){
    const job = getJob(selectedJobId);
    jobCard.classList.toggle("hidden", !job);
    settingsCard.classList.toggle("hidden", !!job);
    if(!job) return;

    jobHeader.textContent = job.title || "Job";
    jobSub.textContent = (job.client ? job.client + " • " : "") + "Updated: " + (job.updatedAt ? job.updatedAt.slice(0,10) : "");

    jobClient.value = job.client || "";
    jobTitle.value = job.title || "";
    jobDesc.value = job.desc || "";
    jobLocation.value = job.location || "";
    jobNotes.value = job.notes || "";
    jobStatus.value = job.status || "QUOTE";
    jobRate.value = job.rateOverride === "" ? "" : (job.rateOverride ?? "");

    tRate.value = jobRateResolved(job);
    if(!tDate.value) tDate.value = new Date().toISOString().slice(0,10);

    renderTime(job);
    renderMats(job);

    pdfType.value = (job.status === "QUOTE") ? "QUOTE" : "INVOICE";
  }

  function renderTime(job){
    const entries = (job.timeEntries || []).slice().sort((a,b)=> (b.date||"").localeCompare(a.date||""));
    timeTableBody.innerHTML = "";
    let totalH = 0, total$ = 0;

    for(const e of entries){
      totalH += Number(e.hours || 0);
      total$ += Number(e.cost || 0);

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${escape(e.date||"")}</td>
        <td>${escape(e.desc||"")}</td>
        <td class="right">${money(e.hours||0)}</td>
        <td class="right">$${money(e.cost||0)}</td>
        <td class="right"><button class="btn ghost" data-del="${e.id}" style="padding:8px 10px">Remove</button></td>
      `;
      timeTableBody.appendChild(tr);
    }

    timeTotals.innerHTML = `Total: <b>${money(totalH)}h</b> • Labour: <b>$${money(total$)}</b>`;
    timeTableBody.querySelectorAll("button[data-del]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-del");
        job.timeEntries = (job.timeEntries || []).filter(x => x.id !== id);
        job.updatedAt = new Date().toISOString();
        saveState();
        await cloudDeleteTime(id).catch(console.error);
        await cloudUpsertJob(job).catch(console.error);
      });
    });
  }

  function renderMats(job){
    const items = (job.materials || []);
    matTableBody.innerHTML = "";
    let total = 0;

    for(const it of items){
      total += Number(it.total || 0);
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${escape(it.item||"")}${it.note ? `<div class="muted">${escape(it.note)}</div>` : ""}</td>
        <td class="right">${money(it.qty||0)}</td>
        <td class="right">$${money(it.total||0)}</td>
        <td class="right"><button class="btn ghost" data-del="${it.id}" style="padding:8px 10px">Remove</button></td>
      `;
      matTableBody.appendChild(tr);
    }

    matTotals.innerHTML = `Materials: <b>$${money(total)}</b>`;
    matTableBody.querySelectorAll("button[data-del]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-del");
        job.materials = (job.materials || []).filter(x => x.id !== id);
        job.updatedAt = new Date().toISOString();
        saveState();
        await cloudDeleteMat(id).catch(console.error);
        await cloudUpsertJob(job).catch(console.error);
      });
    });
  }

  function renderAll(){
    initSettings();
    renderKPIs();
    renderJobList();
    renderSelectedJob();
  }

  // Seed
  if(state.jobs.length === 0){
    const now = new Date().toISOString();
    state.jobs.push({
      id: uid(),
      client: "Sample Client",
      title: "Sample Job (edit or delete)",
      desc: "Example: Fabricate bracket and install.",
      location: "",
      notes: "This is just a starter so you can see the flow.",
      status: "QUOTE",
      rateOverride: "",
      createdAt: now, updatedAt: now,
      timeEntries: [
        { id: uid(), date: now.slice(0,10), desc:"Measure + fitment", hours: 1.5, rate: 75, cost: 112.50, start:"", end:"", breakMin:0 }
      ],
      materials: [
        { id: uid(), item:"Fasteners", qty: 1, unit: 12, sell: null, total: 12, note:"" }
      ]
    });
    saveState();
  } else {
    renderAll();
  }

  /***********************
   * 2) CLOUD FUNCTIONS  *
   ***********************/
  async function cloudPullAll(){
    if(!sb) return;

    // If not logged in, we do nothing (keep local)
    const { data } = await sb.auth.getSession();
    currentUser = data?.session?.user || null;
    if(!currentUser) return;

    const { data: jobs, error: ej } = await sb.from("jobs").select("*").order("updated_at", { ascending:false });
    if(ej){ console.error(ej); return; }

    const { data: te } = await sb.from("time_entries").select("*");
    const { data: ma } = await sb.from("materials").select("*");

    const timeByJob = {};
    (te || []).forEach(e => {
      timeByJob[e.job_id] = timeByJob[e.job_id] || [];
      timeByJob[e.job_id].push({
        id: e.id,
        date: e.work_date,
        desc: e.description || "",
        hours: Number(e.hours || 0),
        rate: Number(e.rate || 0),
        cost: Number(e.cost || 0),
        start:"", end:"", breakMin:0
      });
    });

    const matsByJob = {};
    (ma || []).forEach(m => {
      matsByJob[m.job_id] = matsByJob[m.job_id] || [];
      matsByJob[m.job_id].push({
        id: m.id,
        item: m.item || "",
        qty: Number(m.qty || 0),
        unit: Number(m.unit_cost || 0),
        sell: null,
        total: Number(m.total || 0),
        note: m.note || ""
      });
    });

    state.jobs = (jobs || []).map(j => ({
      id: j.id,
      client: j.client || "",
      title: j.title || "",
      desc: j.description || "",
      location: j.location || "",
      notes: j.notes || "",
      status: j.status || "QUOTE",
      rateOverride: (j.rate_override ?? ""),
      createdAt: j.created_at,
      updatedAt: j.updated_at,
      timeEntries: timeByJob[j.id] || [],
      materials: matsByJob[j.id] || []
    }));

    saveState();
  }

  async function cloudUpsertJob(job){
    if(!canWriteCloud()) return;
    const payload = {
      id: job.id,
      client: job.client,
      title: job.title,
      description: job.desc,
      location: job.location,
      notes: job.notes,
      status: job.status,
      rate_override: (job.rateOverride === "" ? null : job.rateOverride),
      updated_at: new Date().toISOString()
    };
    const { error } = await sb.from("jobs").upsert(payload);
    if(error) throw error;
  }

  async function cloudDeleteJob(jobId){
    if(!canWriteCloud()) return;
    const { error } = await sb.from("jobs").delete().eq("id", jobId);
    if(error) throw error;
  }

  async function cloudInsertTime(jobId, entry){
    if(!canWriteCloud()) return;
    const { error } = await sb.from("time_entries").insert({
      id: entry.id,
      job_id: jobId,
      work_date: entry.date,
      description: entry.desc,
      hours: entry.hours,
      rate: entry.rate,
      cost: entry.cost
    });
    if(error) throw error;
  }

  async function cloudDeleteTime(entryId){
    if(!canWriteCloud()) return;
    const { error } = await sb.from("time_entries").delete().eq("id", entryId);
    if(error) throw error;
  }

  async function cloudInsertMat(jobId, item){
    if(!canWriteCloud()) return;
    const { error } = await sb.from("materials").insert({
      id: item.id,
      job_id: jobId,
      item: item.item,
      qty: item.qty,
      unit_cost: item.unit,
      total: item.total,
      note: item.note
    });
    if(error) throw error;
  }

  async function cloudDeleteMat(itemId){
    if(!canWriteCloud()) return;
    const { error } = await sb.from("materials").delete().eq("id", itemId);
    if(error) throw error;
  }

  async function cloudUpsertSettings(){
    // optional: store settings later if you add a settings table
    return;
  }

  // Realtime (pull on change)
  let rtStarted = false;
  function startRealtime(){
    if(!canWriteCloud() || rtStarted) return;
    rtStarted = true;
    sb.channel("rr-sync")
      .on("postgres_changes", { event:"*", schema:"public", table:"jobs" }, () => cloudPullAll().then(renderAll))
      .on("postgres_changes", { event:"*", schema:"public", table:"time_entries" }, () => cloudPullAll().then(renderAll))
      .on("postgres_changes", { event:"*", schema:"public", table:"materials" }, () => cloudPullAll().then(renderAll))
      .subscribe();
  }

  /***********************
   * 3) ADD FOOTER BUTTONS
   ***********************/
  // Add two buttons into footer (no HTML changes needed)
  const footerToolbar = document.querySelector("footer .toolbar");
  if(footerToolbar){
    const btnSync = document.createElement("button");
    btnSync.className = "btn ghost";
    btnSync.textContent = "Sync / Login";
    btnSync.onclick = () => loginFlow();

    const btnLogout = document.createElement("button");
    btnLogout.className = "btn ghost";
    btnLogout.textContent = "Logout";
    btnLogout.onclick = () => logoutFlow();

    footerToolbar.prepend(btnLogout);
    footerToolbar.prepend(btnSync);

    const status = document.createElement("div");
    status.id = "syncStatus";
    status.className = "small";
    status.style.marginTop = "6px";
    footerToolbar.parentElement.appendChild(status);
  }

  // start passive auth check (no popups)
  initAuthPassive().catch(console.error);

})();
</script>
